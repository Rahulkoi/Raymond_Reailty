<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raymond Realty - Voice Assistant</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0f172a;
            color: #f1f5f9;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .container {
            width: 100%;
            max-width: 500px;
            height: 90vh;
            background: #1e293b;
            border-radius: 20px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 25px 50px rgba(0,0,0,0.5);
        }
        .header {
            padding: 20px;
            background: linear-gradient(135deg, #6366f1, #0ea5e9);
            text-align: center;
        }
        .header h1 { font-size: 1.2rem; }
        .header .status { font-size: 0.85rem; opacity: 0.9; margin-top: 4px; }
        .messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .message {
            max-width: 85%;
            padding: 12px 16px;
            border-radius: 16px;
            line-height: 1.5;
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; } }
        .message.user {
            align-self: flex-end;
            background: linear-gradient(135deg, #6366f1, #4f46e5);
        }
        .message.bot {
            align-self: flex-start;
            background: #334155;
        }
        .property-cards {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 16px;
            animation: fadeIn 0.5s;
        }
        .property-card {
            background: linear-gradient(145deg, rgba(99,102,241,0.15), rgba(14,165,233,0.1));
            border: 1px solid rgba(99,102,241,0.3);
            border-radius: 16px;
            padding: 16px;
            transition: all 0.3s;
        }
        .property-card:hover {
            border-color: #6366f1;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(99,102,241,0.2);
        }
        .property-card h4 {
            color: #818cf8;
            margin-bottom: 8px;
            font-size: 1.05rem;
        }
        .property-card .price {
            color: #10b981;
            font-weight: bold;
            font-size: 1.25rem;
            margin-bottom: 8px;
        }
        .property-card .details {
            color: #94a3b8;
            font-size: 0.85rem;
            margin-bottom: 10px;
            line-height: 1.6;
        }
        .property-card .links {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .property-card .links a {
            background: rgba(99,102,241,0.2);
            color: #818cf8;
            padding: 8px 14px;
            border-radius: 20px;
            text-decoration: none;
            font-size: 0.8rem;
            font-weight: 500;
            transition: all 0.2s;
        }
        .property-card .links a:hover {
            background: #6366f1;
            color: white;
        }
        .fallback-notice {
            background: rgba(245,158,11,0.15);
            border: 1px solid rgba(245,158,11,0.3);
            border-radius: 12px;
            padding: 12px 16px;
            margin-bottom: 12px;
            font-size: 0.9rem;
            color: #fbbf24;
        }
        .controls {
            padding: 20px;
            background: rgba(0,0,0,0.2);
            text-align: center;
        }
        .voice-status {
            margin-bottom: 16px;
            padding: 10px;
            border-radius: 10px;
            font-size: 0.9rem;
        }
        .voice-status.listening { background: rgba(239,68,68,0.2); color: #f87171; }
        .voice-status.speaking { background: rgba(16,185,129,0.2); color: #34d399; }
        .btn-voice {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid #475569;
            background: #334155;
            color: #94a3b8;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-voice:hover { border-color: #6366f1; }
        .btn-voice.active {
            background: #ef4444;
            border-color: #ef4444;
            color: white;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239,68,68,0.5); }
            50% { box-shadow: 0 0 0 15px rgba(239,68,68,0); }
        }
        .typing { display: flex; gap: 4px; padding: 12px 16px; background: #334155; border-radius: 16px; width: fit-content; }
        .typing span { width: 8px; height: 8px; background: #64748b; border-radius: 50%; animation: bounce 1.4s infinite; }
        .typing span:nth-child(2) { animation-delay: 0.2s; }
        .typing span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes bounce { 0%, 60%, 100% { transform: translateY(0); } 30% { transform: translateY(-8px); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Raymond Realty Voice</h1>
            <div class="status" id="status">Click mic to start</div>
        </div>
        <div class="messages" id="messages">
            <div class="message bot">Hi! Click the microphone to start talking with me about properties.</div>
        </div>
        <div class="controls">
            <div class="voice-status" id="voiceStatus">Ready</div>
            <button class="btn-voice" id="voiceBtn" onclick="toggleVoice()">üé§</button>
        </div>
    </div>

    <script>
        let ws = null;
        let isActive = false;
        let audioContext, analyser, microphone, processor, stream;
        let audioQueue = [];
        let isPlaying = false;
        let currentSource = null;
        let playbackCtx = null;
        let propertiesShown = false;

        // Conversation tracking
        let transcript = [];
        let sessionId = 'session_' + Date.now();

        const messagesEl = document.getElementById('messages');
        const voiceBtn = document.getElementById('voiceBtn');
        const voiceStatus = document.getElementById('voiceStatus');
        const statusEl = document.getElementById('status');

        async function toggleVoice() {
            if (isActive) {
                endConversation();
            } else {
                startConversation();
            }
        }

        async function startConversation() {
            propertiesShown = false;
            try {
                statusEl.textContent = 'Connecting...';

                const res = await fetch('/elevenlabs/get-signed-url');
                if (!res.ok) throw new Error('Failed to get signed URL');
                const { signed_url } = await res.json();

                ws = new WebSocket(signed_url);

                ws.onopen = () => {
                    console.log('Connected to ElevenLabs');
                    isActive = true;
                    statusEl.textContent = 'Connected';
                    startMicrophone();
                };

                ws.onmessage = (e) => handleMessage(JSON.parse(e.data));
                ws.onerror = (e) => { console.error('WS error:', e); endConversation(); };
                ws.onclose = () => { if (isActive) endConversation(); };

            } catch (e) {
                console.error('Connection failed:', e);
                statusEl.textContent = 'Connection failed';
            }
        }

        function handleMessage(msg) {
            console.log('Message:', msg.type);

            switch (msg.type) {
                case 'conversation_initiation_metadata':
                    statusEl.textContent = 'Ready - Speak now';
                    updateUI('listening');
                    break;

                case 'user_transcript':
                    const userText = msg.user_transcription_event?.user_transcript || msg.user_transcript;
                    if (userText) {
                        hideTyping();
                        addMessage('user', userText);
                        transcript.push({ role: 'user', text: userText });
                        showTyping();
                    }
                    break;

                case 'agent_response':
                    const botText = msg.agent_response_event?.agent_response || msg.agent_response;
                    if (botText) {
                        hideTyping();
                        addMessage('bot', botText);
                        transcript.push({ role: 'agent', text: botText });

                        // Check if conversation is ending - expanded patterns
                        const lower = botText.toLowerCase();
                        const endingPhrases = [
                            'goodbye', 'bye', 'take care', 'talk soon',
                            'will call you', 'will contact', 'have a great day',
                            'nice talking', 'thank you for', 'thanks for',
                            'been a pleasure', 'look forward', 'speak soon',
                            'reach out', 'get back to you', 'will be in touch'
                        ];
                        const isEnding = endingPhrases.some(phrase => lower.includes(phrase));

                        console.log('Agent response:', botText);
                        console.log('Is ending phrase:', isEnding, 'Properties shown:', propertiesShown);

                        if (isEnding && !propertiesShown) {
                            propertiesShown = true;
                            console.log('Showing properties and capturing lead...');
                            setTimeout(() => showPropertiesAndCaptureLead(), 500);
                        }
                    }
                    break;

                case 'audio':
                    const audio = msg.audio_event?.audio_base_64 || msg.audio;
                    if (audio) {
                        updateUI('speaking');
                        queueAudio(audio);
                    }
                    break;

                case 'ping':
                    const eventId = msg.ping_event?.event_id;
                    if (eventId) ws.send(JSON.stringify({ type: 'pong', event_id: eventId }));
                    break;

                case 'interruption':
                case 'agent_audio_interrupted':
                    stopAudio();
                    updateUI('listening');
                    break;
            }
        }

        async function showPropertiesAndCaptureLead() {
            // Extract search criteria from transcript
            const allUserText = transcript
                .filter(t => t.role === 'user')
                .map(t => t.text)
                .join(' ')
                .toLowerCase();

            // Extract location
            let location = null;
            const locationMap = {
                'bangalore': 'Bangalore',
                'bengaluru': 'Bangalore',
                'banglore': 'Bangalore',
                'thane': 'Thane',
                'mumbai': 'Mumbai',
                'whitefield': 'Whitefield',
                'electronic city': 'Electronic City'
            };
            for (const [key, val] of Object.entries(locationMap)) {
                if (allUserText.includes(key)) {
                    location = val;
                    break;
                }
            }

            // Extract BHK
            let bhk = null;
            const bhkMatch = allUserText.match(/(\d)\s*bhk/);
            if (bhkMatch) bhk = bhkMatch[1] + ' BHK';

            // Extract budget
            let budget = null;
            const crMatch = allUserText.match(/(\d+\.?\d*)\s*(?:crore|cr)/);
            const lakhMatch = allUserText.match(/(\d+\.?\d*)\s*(?:lakh|lac)/);
            if (crMatch) budget = crMatch[1] + ' crore';
            else if (lakhMatch) budget = lakhMatch[1] + ' lakh';

            console.log('üîç Search criteria:', { location, bhk, budget });

            // Fetch properties from API
            try {
                const params = new URLSearchParams();
                if (location) params.append('location', location);
                if (bhk) params.append('bhk', bhk);
                if (budget) params.append('budget', budget);

                const res = await fetch(`/api/properties/search?${params}`);
                const data = await res.json();

                console.log('üè† Properties found:', data);

                if (data.properties && data.properties.length > 0) {
                    showPropertyCards(data.properties, data.is_fallback, location);
                }

            } catch (e) {
                console.error('Property fetch error:', e);
            }

            // Capture lead
            try {
                const res = await fetch('/api/voice/capture-lead', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: sessionId, transcript })
                });
                const data = await res.json();
                console.log('Lead capture:', data);
            } catch (e) {
                console.error('Lead capture error:', e);
            }
        }

        function showPropertyCards(properties, isFallback, searchLocation) {
            const container = document.createElement('div');
            container.className = 'property-cards';

            // Show fallback notice if needed
            if (isFallback) {
                const notice = document.createElement('div');
                notice.className = 'fallback-notice';
                notice.innerHTML = `‚ú® Here are some excellent Raymond Realty projects you might like!`;
                container.appendChild(notice);
            } else if (searchLocation) {
                const notice = document.createElement('div');
                notice.className = 'fallback-notice';
                notice.style.background = 'rgba(16,185,129,0.15)';
                notice.style.borderColor = 'rgba(16,185,129,0.3)';
                notice.style.color = '#34d399';
                notice.innerHTML = `üè† Found ${properties.length} properties in ${searchLocation}`;
                container.appendChild(notice);
            }

            // Add property cards
            properties.forEach(p => {
                const price = formatPrice(p.price);
                const card = document.createElement('div');
                card.className = 'property-card';
                card.innerHTML = `
                    <h4>${escapeHtml(p.name)}</h4>
                    <div class="price">‚Çπ ${price}</div>
                    <div class="details">
                        <strong>${escapeHtml(p.bhk)}</strong> ${escapeHtml(p.type || 'Apartment')} in ${escapeHtml(p.location)}<br>
                        ${p.area_sqft ? `üìê ${p.area_sqft} sq.ft` : ''}
                        ${p.possession ? ` ‚Ä¢ üè† ${escapeHtml(p.possession)}` : ''}
                        ${p.builder ? `<br>üèóÔ∏è ${escapeHtml(p.builder)}` : ''}
                    </div>
                    <div class="links">
                        ${p.property_url ? `<a href="${p.property_url}" target="_blank">üìã Details</a>` : ''}
                        ${p.virtual_tour_url ? `<a href="${p.virtual_tour_url}" target="_blank">üé• Tour</a>` : ''}
                        ${p.contact_number ? `<a href="tel:${p.contact_number}">üìû Call</a>` : ''}
                    </div>
                `;
                container.appendChild(card);
            });

            messagesEl.appendChild(container);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function formatPrice(price) {
            if (!price) return 'On Request';
            if (price >= 10000000) {
                return (price / 10000000).toFixed(2).replace(/\.?0+$/, '') + ' Cr';
            }
            return (price / 100000).toFixed(0) + ' Lakh';
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function endConversation() {
            isActive = false;
            updateUI('inactive');
            statusEl.textContent = 'Click mic to start';

            // Show properties if not already shown
            if (transcript.length > 0 && !propertiesShown) {
                propertiesShown = true;
                showPropertiesAndCaptureLead();
            }

            // Cleanup
            stopMicrophone();
            stopAudio();
            if (ws) { ws.close(); ws = null; }

            // Reset for next conversation
            transcript = [];
            sessionId = 'session_' + Date.now();
        }

        async function startMicrophone() {
            try {
                stream = await navigator.mediaDevices.getUserMedia({
                    audio: { sampleRate: 16000, channelCount: 1, echoCancellation: true, noiseSuppression: true }
                });

                audioContext = new AudioContext({ sampleRate: 16000 });
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);

                processor = audioContext.createScriptProcessor(2048, 1, 1);
                processor.onaudioprocess = (e) => {
                    if (!isActive || !ws || ws.readyState !== WebSocket.OPEN) return;

                    const input = e.inputBuffer.getChannelData(0);
                    const pcm16 = new Int16Array(input.length);
                    for (let i = 0; i < input.length; i++) {
                        const s = Math.max(-1, Math.min(1, input[i]));
                        pcm16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }
                    ws.send(JSON.stringify({ user_audio_chunk: btoa(String.fromCharCode(...new Uint8Array(pcm16.buffer))) }));
                };

                microphone.connect(processor);
                processor.connect(audioContext.destination);
                updateUI('listening');

            } catch (e) {
                console.error('Mic error:', e);
                statusEl.textContent = 'Mic access denied';
            }
        }

        function stopMicrophone() {
            if (processor) { processor.disconnect(); processor = null; }
            if (microphone) { microphone.disconnect(); microphone = null; }
            if (audioContext) { audioContext.close(); audioContext = null; }
            if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
        }

        function queueAudio(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            audioQueue.push(bytes.buffer);
            if (!isPlaying) playNext();
        }

        async function playNext() {
            if (audioQueue.length === 0) {
                isPlaying = false;
                if (isActive) updateUI('listening');
                return;
            }

            isPlaying = true;
            const buffer = audioQueue.shift();

            try {
                if (!playbackCtx) playbackCtx = new AudioContext();
                if (playbackCtx.state === 'suspended') await playbackCtx.resume();

                const audioBuffer = await playbackCtx.decodeAudioData(buffer.slice(0));
                currentSource = playbackCtx.createBufferSource();
                currentSource.buffer = audioBuffer;
                currentSource.connect(playbackCtx.destination);
                currentSource.onended = playNext;
                currentSource.start();
            } catch (e) {
                try {
                    const pcm = new Int16Array(buffer);
                    const float = new Float32Array(pcm.length);
                    for (let i = 0; i < pcm.length; i++) float[i] = pcm[i] / 32768;

                    if (!playbackCtx) playbackCtx = new AudioContext();
                    const audioBuffer = playbackCtx.createBuffer(1, float.length, 16000);
                    audioBuffer.getChannelData(0).set(float);

                    currentSource = playbackCtx.createBufferSource();
                    currentSource.buffer = audioBuffer;
                    currentSource.connect(playbackCtx.destination);
                    currentSource.onended = playNext;
                    currentSource.start();
                } catch (e2) {
                    console.error('Audio error:', e2);
                    playNext();
                }
            }
        }

        function stopAudio() {
            audioQueue = [];
            isPlaying = false;
            if (currentSource) { try { currentSource.stop(); } catch(e){} currentSource = null; }
        }

        function addMessage(role, text) {
            const div = document.createElement('div');
            div.className = 'message ' + role;
            div.textContent = text;
            messagesEl.appendChild(div);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function showTyping() {
            if (document.getElementById('typing')) return;
            const div = document.createElement('div');
            div.id = 'typing';
            div.className = 'typing';
            div.innerHTML = '<span></span><span></span><span></span>';
            messagesEl.appendChild(div);
            messagesEl.scrollTop = messagesEl.scrollHeight;
        }

        function hideTyping() {
            const t = document.getElementById('typing');
            if (t) t.remove();
        }

        function updateUI(state) {
            voiceBtn.className = 'btn-voice' + (state === 'listening' || state === 'speaking' ? ' active' : '');
            voiceStatus.className = 'voice-status ' + state;

            const texts = { inactive: 'Ready', listening: 'Listening...', speaking: 'Speaking...' };
            voiceStatus.textContent = texts[state] || 'Ready';
            voiceBtn.textContent = isActive ? '‚èπÔ∏è' : 'üé§';
        }

        window.onbeforeunload = endConversation;
    </script>
</body>
</html>
